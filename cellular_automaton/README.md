# Elementary cellular automaton

An elementary cellular automaton is a 1-dimensional automaton with two possible states (1 bit) for each cell.
At each time after the initial one, a cell of the automaton depends only on its own state and the states of the adjacent cells at the immediately previous time.
The way this dependence is built is defined by a rule, which is a function giving a binary state from each of the eight (2<sup>3</sup>) possible states of
the three previous cells.
There is thus a set of 256 (2<sup>8</sup>) possible rules which the evolution of the automaton can follow.
There are notable rules which show particular behaviours, such as rule 30 (due to Wolfram) or rule 184 (traffic rule) and many more.

The rule 30 is given by:

| 111 | 110 | 101 | 100 | 011 | 010 | 001 | 000 |
|-----|-----|-----|-----|-----|-----|-----|-----|
|  0  |  0  |  0  |  1  |  1  |  1  |  1  |  0  |

This is what one obtains from rule 30 by starting from a single active cell:

    ...............................0................................
    ..............................000...............................
    .............................00..0..............................
    ............................00.0000.............................
    ...........................00..0...0............................
    ..........................00.0000.000...........................
    .........................00..0....0..0..........................
    ........................00.0000..000000.........................
    .......................00..0...000.....0........................
    ......................00.0000.00..0...000.......................
    .....................00..0....0.0000.00..0......................
    ....................00.0000..00.0....0.0000.....................
    ...................00..0...000..00..00.0...0....................
    ..................00.0000.00..000.000..00.000...................
    .................00..0....0.000...0..000..0..0..................
    ................00.0000..00.0..0.00000..0000000.................
    ...............00..0...000..0000.0....000......0................
    ..............00.0000.00..000....00..00..0....000...............
    .............00..0....0.000..0..00.000.0000..00..0..............
    ............00.0000..00.0..000000..0...0...000.0000.............
    ...........00..0...000..0000.....0000.000.00...0...0............
    ..........00.0000.00..000...0...00....0...0.0.000.000...........
    .........00..0....0.000..0.000.00.0..000.00.0.0...0..0..........
    ........00.0000..00.0..000.0...0..0000...0..0.00.000000.........
    .......00..0...000..0000...00.00000...0.00000.0..0.....0........
    ......00.0000.00..000...0.00..0....0.00.0.....00000...000.......
    .....00..0....0.000..0.00.0.0000..00.0..00...00....0.00..0......
    ....00.0000..00.0..000.0..0.0...000..0000.0.00.0..00.0.0000.....
    ...00..0...000..0000...0000.00.00..000....0.0..0000..0.0...0....
    ..00.0000.00..000...0.00....0..0.000..0..00.0000...000.00.000...
    .00..0....0.000..0.00.0.0..00000.0..000000..0...0.00...0..0..0..
    00.0000..00.0..000.0..0.0000.....0000.....0000.00.0.0.000000000.

where `0` is the active (1) bit state and `.` is the inactive (0) bit state.

## Boundary conditions
